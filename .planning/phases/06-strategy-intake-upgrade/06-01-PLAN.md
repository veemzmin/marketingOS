---
phase: 06-strategy-intake-upgrade
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/strategy/intake-engine.ts
autonomous: true

must_haves:
  truths:
    - "IntakeAnalysis contains confidenceScore (0–100, deterministic rule-based)"
    - "IntakeAnalysis contains evidence: Record<SignalKey, string[]> populated from matchedTerms"
    - "IntakeAnalysis contains requiresVisibilityArchive (true when compliance OR compliance-visibility detected)"
    - "IntakeAnalysis contains requiresApprovalWorkflow (true ONLY when explicit approval gate terms in text)"
    - "IntakeAnalysis contains stakeholdersClarityLevel: 'high' | 'medium' | 'low' (graded, not binary)"
    - "IntakeAnalysis contains stack: string[] (archetype-driven, 3–6 items)"
    - "SignalKey type no longer includes 'stakeholders-unclear' as a detected signal key"
    - "Risk logic triggers 'confirm claims' when ANY of: launch, compliance, referral-enablement, integration-of-care detected"
    - "TypeScript compiles without error after changes"
  artifacts:
    - path: "src/lib/strategy/intake-engine.ts"
      provides: "Engine with all new output fields"
      contains: "confidenceScore"
    - path: "src/lib/strategy/intake-engine.ts"
      provides: "Graded stakeholder clarity"
      contains: "stakeholdersClarityLevel"
    - path: "src/lib/strategy/intake-engine.ts"
      provides: "Split compliance flags"
      contains: "requiresVisibilityArchive"
  key_links:
    - from: "analyzeIntake()"
      to: "IntakeAnalysis"
      via: "return value"
      pattern: "confidenceScore.*stakeholdersClarityLevel.*requiresVisibilityArchive.*stack"
---

<objective>
Upgrade src/lib/strategy/intake-engine.ts to produce all new output fields required by Items 1–5, 7 (guard), 8 (cleanup), and 9 (risk logic fix). This is the engine layer only — no UI or action mapper changes in this plan.

Purpose: The engine is the single source of truth. All downstream consumers (action mapper, UI) depend on these types being correct first.
Output: Updated intake-engine.ts with new types, new fields on IntakeAnalysis, and corrected logic.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@src/lib/strategy/intake-engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update types and IntakeAnalysis interface (Items 1, 2, 3, 5)</name>
  <files>src/lib/strategy/intake-engine.ts</files>
  <action>
Make MINIMAL targeted edits to the types and IntakeAnalysis interface. Do not restructure or reorder existing code.

STEP A — Add StakeholdersClarityLevel type (new, after ExperimentSafetyClass):
```ts
export type StakeholdersClarityLevel = "high" | "medium" | "low"
```

STEP B — Replace the IntakeAnalysis interface. Current interface has these fields:
  signals, detectedSignalKeys, primaryArchetype, secondaryArchetype, cadenceRule,
  experiments, missingInfoQuestions, requiresApprovalWorkflow, plannerPrompt

Replace requiresApprovalWorkflow with TWO flags, and add four new fields:
```ts
export interface IntakeAnalysis {
  signals: Signal[]
  detectedSignalKeys: SignalKey[]
  primaryArchetype: CampaignArchetype
  secondaryArchetype?: CampaignArchetype
  cadenceRule: CadenceRule
  experiments: Experiment[]
  missingInfoQuestions: MissingInfoQuestion[]
  requiresVisibilityArchive: boolean   // NEW — Item 3
  requiresApprovalWorkflow: boolean    // MODIFIED — Item 3 (narrowed trigger)
  confidenceScore: number              // NEW — Item 1
  evidence: Partial<Record<SignalKey, string[]>>  // NEW — Item 2
  stakeholdersClarityLevel: StakeholdersClarityLevel  // NEW — Item 5
  stack: string[]                      // NEW — Item 4
  plannerPrompt: string
}
```

Do NOT change any other types. Do NOT change SignalKey (stakeholders-unclear stays as a signal key for backward compat; it will just never appear in detectedSignalKeys after the graded change).
  </action>
  <verify>TypeScript should accept the new interface. Run: npx tsc --noEmit 2>&1 | head -30 (errors expected until Task 2 fills in implementation)</verify>
  <done>IntakeAnalysis interface has all 8 new/modified fields listed above.</done>
</task>

<task type="auto">
  <name>Task 2: Implement new engine logic — graded clarity, confidence, evidence, split flags, stack, risk fix (Items 1–5, 9)</name>
  <files>src/lib/strategy/intake-engine.ts</files>
  <action>
Make targeted additions and edits inside the analyzeIntake() function and supporting functions. MINIMAL DIFFS ONLY — do not refactor existing functions that are not touched by these items.

CHANGE 1 — Replace detectStakeholdersUnclear with graded function (Item 5).
Remove detectStakeholdersUnclear(). Add this function in its place:

```ts
function detectStakeholdersClarityLevel(text: string): StakeholdersClarityLevel {
  const matchCount = AUDIENCE_TERMS.filter((t) => text.includes(t)).length
  const hasVague = VAGUE_AUDIENCE_TERMS.some((t) => text.includes(t))
  if (hasVague) return "low"
  if (matchCount >= 2) return "high"
  if (matchCount === 1) return "medium"
  return "low"
}
```

CHANGE 2 — Update detectSignals() to use graded clarity (Item 5).
The current detectSignals() injects stakeholders-unclear at the bottom using detectStakeholdersUnclear(). Remove that injection entirely. The stakeholders-unclear signal key can remain in the SignalKey type but should NOT be injected into the signals array anymore (clarity is now exposed via stakeholdersClarityLevel field instead). The detectSignals() function should just map SIGNAL_PATTERNS and return those signals, with no stakeholders-unclear injection.

CHANGE 3 — Add computeEvidence() helper (Item 2).
Add after detectSignals():

```ts
function computeEvidence(signals: Signal[]): Partial<Record<SignalKey, string[]>> {
  const evidence: Partial<Record<SignalKey, string[]>> = {}
  for (const sig of signals) {
    if (sig.detected && sig.matchedTerms.length > 0) {
      evidence[sig.key] = sig.matchedTerms
    }
  }
  return evidence
}
```

CHANGE 4 — Add computeConfidenceScore() helper (Item 1).
Add after computeEvidence():

```ts
const STRONG_SIGNALS: SignalKey[] = ["launch", "referral-enablement", "compliance"]
const SUPPORTING_SIGNALS: SignalKey[] = ["social", "email", "flyer"]

function computeConfidenceScore(
  detectedKeys: SignalKey[],
  clarityLevel: StakeholdersClarityLevel
): number {
  let score = 50
  for (const key of detectedKeys) {
    if (STRONG_SIGNALS.includes(key)) score += 10
    else if (SUPPORTING_SIGNALS.includes(key)) score += 5
  }
  if (clarityLevel === "low") score -= 10
  else if (clarityLevel === "medium") score -= 5
  return Math.min(100, Math.max(0, score))
}
```

CHANGE 5 — Add buildStack() helper (Item 4).
Add after computeConfidenceScore():

```ts
function buildStack(
  primary: CampaignArchetype,
  secondary?: CampaignArchetype
): string[] {
  const stacks: Record<CampaignArchetype, string[]> = {
    "program-launch": [
      "Pre-launch micro-sequence (2 weeks)",
      "Launch-week anchor content",
      "Post-launch 4-week drip",
      "Approval checkpoint template",
    ],
    "referral-enablement": [
      "Provider enablement drip (5–7 touches)",
      "Referral one-pager",
      "LinkedIn post series",
    ],
    "trust-building": [
      "Weekly anchor post series",
      "Monthly newsletter",
      "Educational content clusters",
    ],
    "compliance-visibility": [
      "Milestone communication templates",
      "Documentation/archive snapshot",
      "Stakeholder one-pager",
    ],
  }

  const base = stacks[primary].slice()

  if (secondary) {
    const secondaryAddons: Partial<Record<CampaignArchetype, string>> = {
      "referral-enablement": "Provider enablement one-pager (secondary)",
      "trust-building": "Community awareness post series (secondary)",
      "compliance-visibility": "Compliance milestone note (secondary)",
      "program-launch": "Launch announcement template (secondary)",
    }
    const addon = secondaryAddons[secondary]
    if (addon) base.push(addon)
  }

  return base
}
```

CHANGE 6 — Update analyzeIntake() to compute and return all new fields (Items 1–5, 3, 9).
In analyzeIntake(), make the following changes:

a) After `const signals = detectSignals(combined)`, add:
```ts
const stakeholdersClarityLevel = detectStakeholdersClarityLevel(combined)
```

b) The detectedSignalKeys line stays as-is (filters by detected).

c) After `const { primary, secondary } = selectArchetype(detectedSignalKeys)`, add:
```ts
const evidence = computeEvidence(signals)
const confidenceScore = computeConfidenceScore(detectedSignalKeys, stakeholdersClarityLevel)
const stack = buildStack(primary, secondary)
```

d) Replace the requiresApprovalWorkflow computation. Current code:
```ts
const requiresApprovalWorkflow =
  detectedSignalKeys.includes("compliance") ||
  detectedSignalKeys.includes("compliance-visibility")
```
Replace with TWO flags:
```ts
const requiresVisibilityArchive =
  detectedSignalKeys.includes("compliance") ||
  detectedSignalKeys.includes("compliance-visibility")

const APPROVAL_GATE_TERMS = [
  "approval required", "review required", "sign-off", "must be approved",
  "requires approval", "needs approval", "awaiting approval",
]
const requiresApprovalWorkflow = APPROVAL_GATE_TERMS.some((t) => combined.includes(t))
```

e) Update the partial object to include all new fields:
```ts
const partial: Omit<IntakeAnalysis, "plannerPrompt"> = {
  signals,
  detectedSignalKeys,
  primaryArchetype: primary,
  secondaryArchetype: secondary,
  cadenceRule,
  experiments,
  missingInfoQuestions,
  requiresVisibilityArchive,
  requiresApprovalWorkflow,
  confidenceScore,
  evidence,
  stakeholdersClarityLevel,
  stack,
}
```

CHANGE 7 — Fix risk logic in buildPlannerPrompt (Item 9).
The approvalNote in buildPlannerPrompt() currently checks analysis.requiresApprovalWorkflow. Update it to also check requiresVisibilityArchive:
```ts
const approvalNote =
  analysis.requiresApprovalWorkflow || analysis.requiresVisibilityArchive
    ? "\nAPPROVAL WORKFLOW NOTE: Compliance or state-review signals were detected. Every deliverable section must include an explicit approval checkpoint. No content may be marked ready-to-publish without documented sign-off."
    : ""
```

EDGE CASES TO HANDLE CORRECTLY:
- Text "everyone can benefit" => clarityLevel "low" (vague term match)
- Text "providers and physicians" => matchCount=2, clarityLevel "high"
- Text "referring providers" => matchCount=1, clarityLevel "medium"
- Text with "annual report" and "state approval" but NO "approval required" => requiresVisibilityArchive=true, requiresApprovalWorkflow=false
- Text with "review required" => requiresApprovalWorkflow=true
- Text with only trust-building signals, no specifics => confidenceScore ~50 (base) +5 (trust-building not in strong/supporting) = 50, minus clarity penalty
- Text with "launch" + "referral" + "email" => score = 50 + 10 + 10 + 5 = 75
  </action>
  <verify>
Run: npx tsc --noEmit
Expected: zero errors.
Manually trace one scenario:
  Input text: "We are launching a new IOP program targeting referring physicians and providers"
  Expected: detectedSignalKeys includes "launch" and "referral-enablement"; stakeholdersClarityLevel="high" (physician + provider = 2 terms); confidenceScore = 50+10+10 -0 = 70; requiresVisibilityArchive=false; requiresApprovalWorkflow=false; stack = program-launch stack + referral addon
  </verify>
  <done>
All of the following are true:
- TypeScript compiles clean (npx tsc --noEmit exits 0)
- IntakeAnalysis has confidenceScore, evidence, stakeholdersClarityLevel, stack, requiresVisibilityArchive
- requiresApprovalWorkflow triggers only on explicit gate terms
- requiresVisibilityArchive triggers on compliance/compliance-visibility signals
- stakeholdersClarityLevel is graded (high/medium/low)
- stack is non-empty for every archetype
  </done>
</task>

</tasks>

<verification>
Run `npx tsc --noEmit` from project root. Zero TypeScript errors required.

Manual trace — paste into a Node REPL or test file:
```ts
import { analyzeIntake } from "./src/lib/strategy/intake-engine"

// Case 1: Vague audience
const r1 = analyzeIntake({ intakeText: "We want to reach everyone in the community for general awareness" })
console.assert(r1.stakeholdersClarityLevel === "low")
console.assert(r1.requiresVisibilityArchive === false)
console.assert(r1.requiresApprovalWorkflow === false)

// Case 2: Explicit compliance-visibility, no approval gate
const r2 = analyzeIntake({ intakeText: "We need to produce an annual report demonstrating compliance for our board report" })
console.assert(r2.requiresVisibilityArchive === true)
console.assert(r2.requiresApprovalWorkflow === false)

// Case 3: Explicit approval gate
const r3 = analyzeIntake({ intakeText: "All content review required before publish; approval required from compliance officer" })
console.assert(r3.requiresApprovalWorkflow === true)

// Case 4: Provider audience => high clarity
const r4 = analyzeIntake({ intakeText: "Campaign for referring physicians and primary care providers" })
console.assert(r4.stakeholdersClarityLevel === "high")
console.assert(r4.confidenceScore >= 60)
```
</verification>

<success_criteria>
- npx tsc --noEmit exits 0
- IntakeAnalysis type has all 8 new/modified fields
- All four manual trace assertions pass
- No existing fields removed from IntakeAnalysis
- CADENCE_RULES and EXPERIMENT_LIBRARY exports untouched
</success_criteria>

<output>
After completion, create `.planning/phases/06-strategy-intake-upgrade/06-01-SUMMARY.md`
</output>
