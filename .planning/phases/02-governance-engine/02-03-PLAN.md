---
phase: 02-governance-engine
plan: 03
type: execute
wave: 2
depends_on: [02-01, 02-02]
files_modified:
  - src/lib/governance/validators/stigma-language.ts
  - src/lib/governance/validators/medical-claims.ts
  - src/lib/governance/validators/dsm5-terminology.ts
  - src/lib/governance/validators/treatment-qualification.ts
  - src/lib/governance/validators/suicide-safety.ts
  - src/lib/governance/validators/consent-requirements.ts
  - src/lib/governance/validators/composite.ts
  - src/app/api/governance/validate/route.ts
  - src/app/(dashboard)/governance/test/page.tsx
autonomous: false

must_haves:
  truths:
    - "System validates content against 5-7 core healthcare policies in real-time"
    - "System flags unsupported medical claims automatically"
    - "System detects and flags stigmatizing mental health language (50-100 terms)"
    - "System validates DSM-5 terminology usage"
    - "System requires qualified statements for treatment advice"
    - "System flags content discussing suicide without crisis resources"
    - "System requires consent documentation for patient testimonials"
    - "System provides 0-100 compliance score with clear reasoning"
    - "System provides inline suggestions for fixing policy violations"
  artifacts:
    - path: "src/lib/governance/validators/stigma-language.ts"
      provides: "Stigma language validator using word-boundary regex"
      exports: ["validateStigmaLanguage"]
      contains: "\\\\b.*\\\\b.*regex"
    - path: "src/lib/governance/validators/medical-claims.ts"
      provides: "Medical claims validator with context awareness"
      exports: ["validateMedicalClaims"]
      min_lines: 30
    - path: "src/lib/governance/validators/composite.ts"
      provides: "Composite validator orchestrating all 6 validators in parallel"
      exports: ["validateContent", "Violation"]
      contains: "Promise.all"
    - path: "src/app/api/governance/validate/route.ts"
      provides: "Validation API endpoint"
      exports: ["POST"]
      contains: "calculateComplianceScore"
    - path: "src/app/(dashboard)/governance/test/page.tsx"
      provides: "Test UI for validation flow"
      min_lines: 80
  key_links:
    - from: "src/lib/governance/validators/stigma-language.ts"
      to: "src/lib/governance/policies/stigma-language.ts"
      via: "import { STIGMA_TERMS }"
      pattern: "import.*STIGMA_TERMS"
    - from: "src/lib/governance/validators/composite.ts"
      to: "all validator files"
      via: "import { validateStigmaLanguage, validateMedicalClaims, ... }"
      pattern: "import.*validate.*from"
    - from: "src/app/api/governance/validate/route.ts"
      to: "src/lib/governance/validators/composite.ts"
      via: "import { validateContent }"
      pattern: "validateContent\\("
    - from: "src/app/api/governance/validate/route.ts"
      to: "src/lib/governance/scoring/calculator.ts"
      via: "import { calculateComplianceScore }"
      pattern: "calculateComplianceScore\\("
---

<objective>
Implement the complete governance validation pipeline: 6 policy validators executing in parallel, composite orchestrator, API endpoint, and test UI. This delivers the core Phase 2 capability - real-time policy validation with compliance scoring.

Purpose: Enable automated policy enforcement that catches healthcare compliance violations before content reaches review. Each validator detects specific policy violations (stigma, medical claims, safety issues) and returns actionable feedback.

Output: Working validation API that accepts content and returns violations + compliance score, plus test UI to verify all policies.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-governance-engine/02-CONTEXT.md
@.planning/phases/02-governance-engine/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement 6 policy validators</name>
  <files>
    src/lib/governance/validators/stigma-language.ts
    src/lib/governance/validators/medical-claims.ts
    src/lib/governance/validators/dsm5-terminology.ts
    src/lib/governance/validators/treatment-qualification.ts
    src/lib/governance/validators/suicide-safety.ts
    src/lib/governance/validators/consent-requirements.ts
  </files>
  <action>
Create 6 validator implementations following research patterns:

**stigma-language.ts** (word-boundary regex pattern):
```typescript
import { STIGMA_TERMS } from '../policies/stigma-language'
import type { Violation } from '../types'

export async function validateStigmaLanguage(content: string): Promise<Violation[]> {
  const violations: Violation[] = []

  for (const term of STIGMA_TERMS) {
    // Use word boundary regex to avoid partial matches
    const regex = new RegExp(`\\b${term}\\b`, 'gi')
    let match

    while ((match = regex.exec(content)) !== null) {
      violations.push({
        policyId: 'stigma-language',
        severity: 'medium',
        text: content.substring(
          Math.max(0, match.index - 20),
          Math.min(content.length, match.index + match[0].length + 20)
        ),
        explanation: `"${match[0]}" is stigmatizing language. Use person-first or strengths-based language instead.`,
        startIndex: match.index,
        endIndex: match.index + match[0].length,
      })
    }
  }

  return violations
}
```

**medical-claims.ts** (context-aware pattern matching):
```typescript
import { UNSUPPORTED_CLAIMS } from '../policies/medical-claims'
import type { Violation } from '../types'

export async function validateMedicalClaims(content: string): Promise<Violation[]> {
  const violations: Violation[] = []

  for (const claim of UNSUPPORTED_CLAIMS) {
    // Context-aware: "cure" near "mental health" context
    const contextRegex = new RegExp(
      `\\b${claim.term}\\b[^.]*\\b(mental|psychiatric|psychological|emotional|behavioral|depression|anxiety)`,
      'gi'
    )

    let match
    while ((match = contextRegex.exec(content)) !== null) {
      violations.push({
        policyId: 'medical-claims',
        severity: 'high',
        text: content.substring(
          Math.max(0, match.index - 30),
          Math.min(content.length, match.index + match[0].length + 30)
        ),
        explanation: `"${claim.term}" is not supported as a medical claim for ${claim.context}. Instead, use "${claim.alternative}".`,
        startIndex: match.index,
        endIndex: match.index + match[0].length,
      })
    }
  }

  return violations
}
```

**dsm5-terminology.ts** (inverse validation - flag unknown terms):
```typescript
import { DSM5_TERMS } from '../policies/dsm5-terminology'
import type { Violation } from '../types'

export async function validateDSM5Terminology(content: string): Promise<Violation[]> {
  const violations: Violation[] = []

  // Look for diagnostic terms NOT in DSM5_TERMS list
  // Pattern: "diagnosed with X" or "has X disorder/condition"
  const diagnosisPattern = /(?:diagnosed with|has|suffering from|living with)\s+([a-z\s]+(?:disorder|condition|syndrome))/gi
  let match

  while ((match = diagnosisPattern.exec(content)) !== null) {
    const term = match[1].trim().toLowerCase()
    const isValid = DSM5_TERMS.some(dsm5Term => term.includes(dsm5Term.toLowerCase()))

    if (!isValid) {
      violations.push({
        policyId: 'dsm5-terminology',
        severity: 'medium',
        text: match[0],
        explanation: `"${term}" may not be valid DSM-5 terminology. Verify against DSM-5-TR or use general language.`,
        startIndex: match.index,
        endIndex: match.index + match[0].length,
      })
    }
  }

  return violations
}
```

**treatment-qualification.ts** (unqualified advice detection):
```typescript
import { UNQUALIFIED_LANGUAGE } from '../policies/treatment-qualification'
import type { Violation } from '../types'

export async function validateTreatmentQualification(content: string): Promise<Violation[]> {
  const violations: Violation[] = []

  for (const phrase of UNQUALIFIED_LANGUAGE) {
    const regex = new RegExp(phrase.term, 'gi')
    let match

    while ((match = regex.exec(content)) !== null) {
      violations.push({
        policyId: 'treatment-qualification',
        severity: 'high',
        text: content.substring(
          Math.max(0, match.index - 20),
          Math.min(content.length, match.index + match[0].length + 20)
        ),
        explanation: `"${match[0]}" is unqualified treatment advice. Use "${phrase.qualified}" instead.`,
        startIndex: match.index,
        endIndex: match.index + match[0].length,
      })
    }
  }

  return violations
}
```

**suicide-safety.ts** (require crisis resources when suicide mentioned):
```typescript
import { SUICIDE_KEYWORDS, REQUIRED_RESOURCES, hasRequiredCrisisResources } from '../policies/suicide-safety'
import type { Violation } from '../types'

export async function validateSuicideSafety(content: string): Promise<Violation[]> {
  const violations: Violation[] = []
  const lowerContent = content.toLowerCase()

  // Check if content discusses suicide
  const discussesSuicide = SUICIDE_KEYWORDS.some(keyword => lowerContent.includes(keyword))

  if (discussesSuicide) {
    // If discussing suicide, MUST include crisis resources
    if (!hasRequiredCrisisResources(content)) {
      violations.push({
        policyId: 'suicide-safety',
        severity: 'high',
        text: 'Content discusses suicide without crisis resources',
        explanation: `Content mentions suicide but does not include required crisis resources (988 Lifeline or Crisis Text Line). Add: "If you're in crisis, call 988 or text HOME to 741741."`,
        startIndex: 0,
        endIndex: 0, // Whole-content violation
      })
    }
  }

  return violations
}
```

**consent-requirements.ts** (patient testimonial consent check):
```typescript
import { TESTIMONIAL_INDICATORS, CONSENT_PATTERNS } from '../policies/consent-requirements'
import type { Violation } from '../types'

export async function validateConsentRequirement(content: string): Promise<Violation[]> {
  const violations: Violation[] = []
  const lowerContent = content.toLowerCase()

  // Check if content includes patient testimonial
  const hasTestimonial = TESTIMONIAL_INDICATORS.some(indicator => lowerContent.includes(indicator))

  if (hasTestimonial) {
    // If testimonial present, MUST mention consent
    const hasConsent = CONSENT_PATTERNS.some(pattern => lowerContent.includes(pattern))

    if (!hasConsent) {
      violations.push({
        policyId: 'consent',
        severity: 'medium',
        text: 'Patient testimonial without documented consent',
        explanation: `Content includes patient story/testimonial but does not mention consent. Add: "Shared with written consent" or similar HIPAA-compliant language.`,
        startIndex: 0,
        endIndex: 0, // Whole-content violation
      })
    }
  }

  return violations
}
```

Use research patterns: word-boundary regex for stigma, context-aware matching for medical claims, inverse validation for DSM-5. All validators return Violation[] and are async for future API calls (DSM-5 API in Phase 3+).
  </action>
  <verify>
```bash
npx tsc --noEmit --project tsconfig.json
```
No type errors. All validators export validate* functions returning Promise<Violation[]>.
  </verify>
  <done>6 policy validators implemented with research-validated patterns (word-boundary regex, context awareness, inverse validation).</done>
</task>

<task type="auto">
  <name>Task 2: Create composite validator and API endpoint</name>
  <files>
    src/lib/governance/validators/composite.ts
    src/app/api/governance/validate/route.ts
  </files>
  <action>
Create composite validator orchestrating all 6 validators in parallel:

**composite.ts:**
```typescript
import { validateMedicalClaims } from './medical-claims'
import { validateStigmaLanguage } from './stigma-language'
import { validateDSM5Terminology } from './dsm5-terminology'
import { validateTreatmentQualification } from './treatment-qualification'
import { validateSuicideSafety } from './suicide-safety'
import { validateConsentRequirement } from './consent-requirements'

export type { Violation } from '../types'

export async function validateContent(content: string): Promise<Violation[]> {
  // Run all validators in parallel
  const [
    medicalViolations,
    stigmaViolations,
    dsm5Violations,
    qualificationViolations,
    suicideViolations,
    consentViolations,
  ] = await Promise.all([
    validateMedicalClaims(content),
    validateStigmaLanguage(content),
    validateDSM5Terminology(content),
    validateTreatmentQualification(content),
    validateSuicideSafety(content),
    validateConsentRequirement(content),
  ])

  // Combine and sort by position in content
  return [
    ...medicalViolations,
    ...stigmaViolations,
    ...dsm5Violations,
    ...qualificationViolations,
    ...suicideViolations,
    ...consentViolations,
  ].sort((a, b) => a.startIndex - b.startIndex)
}
```

**API route (validate/route.ts):**
```typescript
import { z } from 'zod'
import { validateContent } from '@/lib/governance/validators/composite'
import { calculateComplianceScore } from '@/lib/governance/scoring/calculator'
import { auth } from '@/lib/auth'
import { prisma } from '@/lib/db/client'

const ValidateRequest = z.object({
  content: z.string().min(1).max(50000),
  contentId: z.string().optional(),
})

export async function POST(request: Request) {
  try {
    const session = await auth()
    if (!session?.user?.organizationId) {
      return Response.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { content, contentId } = ValidateRequest.parse(body)

    // Run validation
    const violations = await validateContent(content)
    const complianceScore = calculateComplianceScore(violations)

    // Audit log the validation check
    await prisma.auditLog.create({
      data: {
        organizationId: session.user.organizationId,
        userId: session.user.id,
        action: 'governance-validation',
        resource: 'content',
        resourceId: contentId || 'test',
        changes: {
          complianceScore: complianceScore.score,
          violationCount: violations.length,
          policies: violations.map(v => v.policyId),
        },
      },
    })

    return Response.json({
      success: true,
      complianceScore: complianceScore.score,
      violations: violations.map(v => ({
        policyId: v.policyId,
        severity: v.severity,
        text: v.text,
        explanation: v.explanation,
        startIndex: v.startIndex,
        endIndex: v.endIndex,
      })),
      reasoning: complianceScore.reasoning,
      passed: complianceScore.passed,
    })
  } catch (error) {
    if (error instanceof z.ZodError) {
      return Response.json(
        { error: 'Invalid request', details: error.errors },
        { status: 400 }
      )
    }

    console.error('Validation failed:', error)
    return Response.json(
      { error: 'Validation service error' },
      { status: 500 }
    )
  }
}
```

Use Phase 1 auth patterns (requireSession, audit logging via Prisma). Follow research: parallel execution via Promise.all, Zod validation, non-blocking audit logging.
  </action>
  <verify>
```bash
npx tsc --noEmit --project tsconfig.json
```
No type errors. Composite validator exports validateContent. API route exports POST handler.
  </verify>
  <done>Composite validator orchestrates all 6 validators in parallel. API endpoint integrates validation + scoring with auth and audit logging.</done>
</task>

<task type="auto">
  <name>Task 3: Create test UI for validation flow</name>
  <files>src/app/(dashboard)/governance/test/page.tsx</files>
  <action>
Create test UI page for governance validation:

```typescript
'use client'

import { useState } from 'react'

interface Violation {
  policyId: string
  severity: string
  text: string
  explanation: string
}

export default function GovernanceTestPage() {
  const [content, setContent] = useState('')
  const [loading, setLoading] = useState(false)
  const [result, setResult] = useState<{
    complianceScore: number
    violations: Violation[]
    reasoning: string[]
    passed: string[]
  } | null>(null)

  const handleValidate = async () => {
    setLoading(true)
    try {
      const res = await fetch('/api/governance/validate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content }),
      })
      const data = await res.json()
      setResult(data)
    } catch (error) {
      console.error('Validation failed:', error)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="container mx-auto p-8 max-w-6xl">
      <h1 className="text-3xl font-bold mb-6">Governance Engine Test</h1>

      <div className="grid grid-cols-2 gap-8">
        {/* Left: Input */}
        <div>
          <label className="block mb-2 font-medium">
            Content to Validate
          </label>
          <textarea
            value={content}
            onChange={(e) => setContent(e.target.value)}
            className="w-full h-96 p-4 border rounded-lg font-mono text-sm"
            placeholder="Enter content to test governance validation..."
          />
          <button
            onClick={handleValidate}
            disabled={loading || !content}
            className="mt-4 px-6 py-2 bg-blue-600 text-white rounded-lg disabled:opacity-50"
          >
            {loading ? 'Validating...' : 'Validate Content'}
          </button>
        </div>

        {/* Right: Results */}
        <div>
          {result && (
            <div>
              <div className="mb-6 p-4 bg-gray-50 rounded-lg">
                <h2 className="text-xl font-bold mb-2">
                  Compliance Score: {result.complianceScore}/100
                </h2>
                <div className="w-full bg-gray-200 rounded-full h-4">
                  <div
                    className={`h-4 rounded-full ${
                      result.complianceScore >= 80
                        ? 'bg-green-500'
                        : result.complianceScore >= 60
                        ? 'bg-yellow-500'
                        : 'bg-red-500'
                    }`}
                    style={{ width: `${result.complianceScore}%` }}
                  />
                </div>
                <div className="mt-4 text-sm">
                  <p className="font-medium mb-2">Score Breakdown:</p>
                  <ul className="space-y-1">
                    {result.reasoning.map((reason, i) => (
                      <li key={i} className="text-gray-700">• {reason}</li>
                    ))}
                  </ul>
                </div>
              </div>

              <div className="mb-4">
                <h3 className="font-bold mb-2">
                  Violations ({result.violations.length})
                </h3>
                {result.violations.length === 0 ? (
                  <p className="text-green-600">No violations found!</p>
                ) : (
                  <div className="space-y-3">
                    {result.violations.map((v, i) => (
                      <div key={i} className="p-3 bg-red-50 border-l-4 border-red-500 rounded">
                        <p className="font-medium text-sm text-red-800">
                          {v.policyId} ({v.severity})
                        </p>
                        <p className="text-sm text-gray-700 mt-1 italic">
                          "{v.text}"
                        </p>
                        <p className="text-sm text-gray-600 mt-2">
                          {v.explanation}
                        </p>
                      </div>
                    ))}
                  </div>
                )}
              </div>

              <div>
                <h3 className="font-bold mb-2 text-green-700">
                  Passed Policies ({result.passed.length})
                </h3>
                <div className="flex flex-wrap gap-2">
                  {result.passed.map(p => (
                    <span key={p} className="px-3 py-1 bg-green-100 text-green-800 rounded-full text-sm">
                      {p}
                    </span>
                  ))}
                </div>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Test Cases */}
      <div className="mt-8 p-4 bg-blue-50 rounded-lg">
        <h3 className="font-bold mb-3">Quick Test Cases</h3>
        <div className="grid grid-cols-3 gap-2">
          <button
            onClick={() => setContent('Our new treatment cures depression and anxiety in just 2 weeks! Contact us today.')}
            className="p-2 bg-white border rounded text-sm hover:bg-gray-50"
          >
            Medical Claims Violation
          </button>
          <button
            onClick={() => setContent('Many addicts and junkies struggle with mental health issues.')}
            className="p-2 bg-white border rounded text-sm hover:bg-gray-50"
          >
            Stigma Language Violation
          </button>
          <button
            onClick={() => setContent('If you are feeling suicidal, please know you are not alone.')}
            className="p-2 bg-white border rounded text-sm hover:bg-gray-50"
          >
            Suicide Safety Violation
          </button>
          <button
            onClick={() => setContent('Therapy may help reduce symptoms of depression and anxiety when combined with other treatments.')}
            className="p-2 bg-white border rounded text-sm hover:bg-gray-50"
          >
            Compliant Content
          </button>
        </div>
      </div>
    </div>
  )
}
```

Use Tailwind for styling. Show compliance score with color-coded progress bar. Display violations with policy ID, severity, snippet, and explanation. Include quick test buttons for common violation scenarios.
  </action>
  <verify>
```bash
npm run build
```
Build succeeds. Test UI page compiles without errors.
  </verify>
  <done>Test UI created with validation form, score display, violation list, and quick test cases.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete governance validation system:
- 6 policy validators (stigma, medical claims, DSM-5, treatment qualification, suicide safety, consent)
- Composite validator executing in parallel
- Compliance scoring with weighted penalties
- Validation API endpoint with auth and audit logging
- Test UI for validation flow
  </what-built>
  <how-to-verify>
1. Start dev server: `npm run dev`
2. Navigate to http://localhost:3000/governance/test
3. Test each violation type using quick test buttons:
   - Medical Claims: Should flag "cures depression"
   - Stigma Language: Should flag "addicts and junkies"
   - Suicide Safety: Should flag suicide mention without 988
4. Test compliant content: Should score 100/100
5. Verify compliance score calculation:
   - Medical claims violation: ~75/100 (100 - 25)
   - Multiple stigma terms: Check additive penalty (2 terms = -10)
6. Check violation explanations are clear and actionable
7. Verify reasoning breakdown shows which policies passed/failed
8. Check browser console for errors
9. Verify audit log entry created (check database or logs)

**Expected results:**
- Violations displayed with policy ID, snippet, and explanation
- Compliance score updates based on violations
- Score breakdown shows reasoning
- Color-coded score bar (green ≥80, yellow 60-79, red <60)
- No console errors
  </how-to-verify>
  <resume-signal>
Type "approved" if validation works as expected, or describe issues to fix.
  </resume-signal>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - no type errors across governance module
2. Test API endpoint:
```bash
curl -X POST http://localhost:3000/api/governance/validate \
  -H "Content-Type: application/json" \
  -d '{"content": "Our treatment cures depression."}'
```
Returns compliance score and violations.
3. Access test UI at /governance/test and validate all quick test cases
4. Verify audit log entries created in database for validation checks
5. Check all 6 validators execute (test content triggering each policy)
</verification>

<success_criteria>
- [ ] 9 files created (6 validators, 1 composite, 1 API route, 1 test UI)
- [ ] All 6 policy validators implemented with research patterns
- [ ] Composite validator executes validators in parallel via Promise.all
- [ ] API endpoint returns compliance score + violations + reasoning
- [ ] Test UI displays violations with clear explanations
- [ ] Compliance score calculated correctly with weighted penalties
- [ ] Medical claims and suicide safety violations produce high penalties
- [ ] Stigma language violations are additive (capped at 30 points)
- [ ] Validation creates audit log entries
- [ ] TypeScript compilation and build succeed with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-governance-engine/02-03-SUMMARY.md` using the summary template.
</output>
