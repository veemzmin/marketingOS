---
phase: 03-content-creation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/validators/content-schema.ts
  - src/lib/actions/content.ts
  - src/lib/content/types.ts
  - src/lib/content/helpers.ts
autonomous: true

must_haves:
  truths:
    - "Server validates content against governance policies before saving"
    - "Compliance score stored with each version"
    - "Status transitions enforced (DRAFT can only go to SUBMITTED, etc.)"
    - "Auto-save only creates version if content actually changed"
  artifacts:
    - path: "src/lib/validators/content-schema.ts"
      provides: "Zod schema for content form validation"
      exports: ["contentFormSchema", "ContentFormData"]
    - path: "src/lib/actions/content.ts"
      provides: "Server actions for content CRUD"
      exports: ["saveDraftAction", "submitContentAction", "listContentAction", "validateGovernanceAction"]
    - path: "src/lib/content/types.ts"
      provides: "Content type definitions and status machine"
      exports: ["ContentStatus", "statusTransitions", "canTransitionTo"]
    - path: "src/lib/content/helpers.ts"
      provides: "Content versioning helpers"
      exports: ["getLatestVersion", "createNewVersion"]
  key_links:
    - from: "saveDraftAction"
      to: "validateContent (from Phase 2)"
      via: "import from governance validators"
      pattern: "import.*validateContent.*from.*governance"
    - from: "saveDraftAction"
      to: "db.content.create/update"
      via: "Prisma client calls"
      pattern: "db\\.content\\.(create|update)"
    - from: "contentFormSchema"
      to: "ContentVersion fields"
      via: "Zod schema mirrors database fields"
      pattern: "z\\.string|z\\.enum"
---

<objective>
Build server-side logic for content creation, versioning, and governance validation.

Purpose: Implement CRUD operations with governance integration, status workflow enforcement, and intelligent versioning.

Output: Server actions for saving drafts, submitting content, listing content; Zod validation schemas; type-safe status transitions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-content-creation/03-RESEARCH.md
@.planning/phases/02-governance-engine/02-SUMMARY.md
@prisma/schema.prisma
@src/lib/governance/validators/composite.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create content validation schemas and type definitions</name>
  <files>
    src/lib/validators/content-schema.ts
    src/lib/content/types.ts
    src/lib/content/helpers.ts
  </files>
  <action>
Create type-safe content validation and workflow management:

**1. src/lib/validators/content-schema.ts** - Zod schema for client/server validation:

```typescript
import { z } from 'zod'

export const contentFormSchema = z.object({
  title: z.string().min(5, 'Title must be at least 5 characters').max(200, 'Title must be less than 200 characters'),
  body: z.string().min(50, 'Content must be at least 50 characters').max(50000, 'Content must be less than 50,000 characters'),
  topic: z.enum(['mental-health', 'substance-use', 'wellness', 'crisis'], {
    errorMap: () => ({ message: 'Invalid topic' }),
  }),
  audience: z.enum(['patients', 'families', 'professionals', 'general'], {
    errorMap: () => ({ message: 'Invalid audience' }),
  }),
  tone: z.enum(['informative', 'supportive', 'clinical', 'motivational'], {
    errorMap: () => ({ message: 'Invalid tone' }),
  }),
})

export type ContentFormData = z.infer<typeof contentFormSchema>
```

**2. src/lib/content/types.ts** - Status workflow state machine:

```typescript
export type ContentStatus = 'DRAFT' | 'SUBMITTED' | 'IN_REVIEW' | 'APPROVED' | 'REJECTED'

// State machine: defines allowed transitions
export const statusTransitions: Record<ContentStatus, ContentStatus[]> = {
  DRAFT: ['SUBMITTED'], // Creator submits draft
  SUBMITTED: ['IN_REVIEW', 'DRAFT'], // Reviewer starts review OR creator cancels
  IN_REVIEW: ['APPROVED', 'REJECTED'], // Reviewer makes decision
  APPROVED: [], // Terminal state
  REJECTED: ['DRAFT'], // Creator can revise and resubmit
}

export function canTransitionTo(currentStatus: ContentStatus, newStatus: ContentStatus): boolean {
  return statusTransitions[currentStatus].includes(newStatus)
}

export interface ContentWithVersion {
  id: string
  title: string
  status: ContentStatus
  complianceScore: number | null
  createdAt: Date
  updatedAt: Date
  latestVersion: {
    versionNumber: number
    body: string
    topic: string
    audience: string
    tone: string
    complianceScore: number
  } | null
}
```

**3. src/lib/content/helpers.ts** - Versioning utilities:

```typescript
import { db } from '@/lib/db/client'

export async function getLatestVersion(contentId: string) {
  return db.contentVersion.findFirst({
    where: { contentId },
    orderBy: { versionNumber: 'desc' },
  })
}

export async function shouldCreateVersion(contentId: string, newBody: string): Promise<boolean> {
  const latestVersion = await getLatestVersion(contentId)
  if (!latestVersion) return true

  // Only create version if content actually changed
  return latestVersion.body !== newBody
}
```
  </action>
  <verify>
Files exist: src/lib/validators/content-schema.ts, src/lib/content/types.ts, src/lib/content/helpers.ts
TypeScript compiles without errors: `npx tsc --noEmit`
Exports available (check with `grep -r "export" src/lib/validators/content-schema.ts src/lib/content/`)
  </verify>
  <done>
Zod schema defines content form validation rules.
Status state machine prevents invalid transitions.
Versioning helpers prevent duplicate versions on unchanged content.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement server actions with governance integration</name>
  <files>src/lib/actions/content.ts</files>
  <action>
Create server actions for content CRUD with governance validation:

**src/lib/actions/content.ts**:

```typescript
'use server'

import { auth } from '@/auth'
import { db } from '@/lib/db/client'
import { headers } from 'next/headers'
import { validateContent } from '@/lib/governance/validators/composite'
import { calculateComplianceScore } from '@/lib/governance/scoring'
import { contentFormSchema, type ContentFormData } from '@/lib/validators/content-schema'
import { canTransitionTo } from '@/lib/content/types'
import { shouldCreateVersion } from '@/lib/content/helpers'

export async function saveDraftAction({
  contentId,
  formData,
}: {
  contentId?: string
  formData: ContentFormData
}) {
  const session = await auth()
  const headersList = headers()
  const organizationId = headersList.get('x-tenant-id')

  if (!session?.user?.id || !organizationId) {
    return { success: false, error: 'Unauthorized' }
  }

  // Validate form data
  const parsed = contentFormSchema.safeParse(formData)
  if (!parsed.success) {
    return { success: false, error: 'Invalid form data', issues: parsed.error.issues }
  }

  const { title, body, topic, audience, tone } = parsed.data

  // Run governance validation
  const violations = await validateContent(body)
  const { score } = calculateComplianceScore(violations)

  try {
    if (!contentId) {
      // Create new draft
      const content = await db.content.create({
        data: {
          organizationId,
          createdByUserId: session.user.id,
          title,
          status: 'DRAFT',
          complianceScore: score,
          versions: {
            create: {
              versionNumber: 1,
              title,
              body,
              topic,
              audience,
              tone,
              complianceScore: score,
              createdByUserId: session.user.id,
            },
          },
        },
        include: {
          versions: { orderBy: { versionNumber: 'desc' }, take: 1 },
        },
      })
      return { success: true, contentId: content.id, complianceScore: score }
    } else {
      // Update existing draft
      const content = await db.content.findUnique({
        where: { id: contentId, organizationId },
        include: { versions: { orderBy: { versionNumber: 'desc' }, take: 1 } },
      })

      if (!content) {
        return { success: false, error: 'Content not found' }
      }

      if (content.status !== 'DRAFT') {
        return { success: false, error: 'Can only edit draft content' }
      }

      // Check if content actually changed
      const shouldCreate = await shouldCreateVersion(contentId, body)
      if (!shouldCreate) {
        return { success: true, contentId, skipped: true }
      }

      // Create new version
      const latestVersion = content.versions[0]
      const newVersionNumber = (latestVersion?.versionNumber || 0) + 1

      await db.content.update({
        where: { id: contentId },
        data: {
          title,
          complianceScore: score,
          versions: {
            create: {
              versionNumber: newVersionNumber,
              title,
              body,
              topic,
              audience,
              tone,
              complianceScore: score,
              createdByUserId: session.user.id,
            },
          },
        },
      })

      return { success: true, contentId, complianceScore: score }
    }
  } catch (error) {
    console.error('Save draft failed:', error)
    return { success: false, error: 'Failed to save draft' }
  }
}

export async function validateGovernanceAction(content: string) {
  // Wrapper for real-time UI validation (no auth required for read-only validation)
  const violations = await validateContent(content)
  const { score } = calculateComplianceScore(violations)

  return { violations, complianceScore: score }
}

export async function submitContentAction({ contentId }: { contentId: string }) {
  const session = await auth()
  const headersList = headers()
  const organizationId = headersList.get('x-tenant-id')

  if (!session?.user?.id || !organizationId) {
    return { success: false, error: 'Unauthorized' }
  }

  const content = await db.content.findUnique({
    where: { id: contentId, organizationId },
  })

  if (!content) {
    return { success: false, error: 'Content not found' }
  }

  // Validate status transition
  if (!canTransitionTo(content.status as any, 'SUBMITTED')) {
    return { success: false, error: `Cannot submit content in ${content.status} status` }
  }

  // Update status
  await db.content.update({
    where: { id: contentId },
    data: { status: 'SUBMITTED' },
  })

  return { success: true }
}

export async function listContentAction({ status }: { status?: string } = {}) {
  const session = await auth()
  const headersList = headers()
  const organizationId = headersList.get('x-tenant-id')

  if (!session?.user?.id || !organizationId) {
    return { success: false, error: 'Unauthorized', contents: [] }
  }

  const contents = await db.content.findMany({
    where: {
      organizationId,
      ...(status ? { status: status as any } : {}),
    },
    orderBy: { updatedAt: 'desc' },
    include: {
      versions: { orderBy: { versionNumber: 'desc' }, take: 1 },
      createdBy: { select: { name: true, email: true } },
    },
  })

  return { success: true, contents }
}

export async function getContentAction({ contentId }: { contentId: string }) {
  const session = await auth()
  const headersList = headers()
  const organizationId = headersList.get('x-tenant-id')

  if (!session?.user?.id || !organizationId) {
    return { success: false, error: 'Unauthorized', content: null }
  }

  const content = await db.content.findUnique({
    where: { id: contentId, organizationId },
    include: {
      versions: { orderBy: { versionNumber: 'desc' } },
      createdBy: { select: { name: true, email: true } },
    },
  })

  if (!content) {
    return { success: false, error: 'Content not found', content: null }
  }

  return { success: true, content }
}
```

**Key implementation details from research:**
- Governance validation on EVERY save (not just submit)
- Compliance score stored with each version (snapshot at creation time)
- Status transition validation using canTransitionTo
- Version only created if body changed (prevents noise from auto-save)
- 1-second debounce handled in UI, not here (server action is immediate)
- **validateGovernanceAction** wraps validateContent() from Phase 2 for real-time UI validation (no auth required since it's read-only advisory feedback)
  </action>
  <verify>
File exists: src/lib/actions/content.ts
TypeScript compiles: `npx tsc --noEmit`
Server actions export properly: `grep "export async function" src/lib/actions/content.ts` shows saveDraftAction, submitContentAction, listContentAction, getContentAction
  </verify>
  <done>
Server actions handle content creation, updating, submission, and listing.
Governance validation integrated into save workflow.
Status transitions enforced server-side.
Intelligent versioning prevents duplicate records on unchanged content.
validateGovernanceAction wrapper available for real-time UI validation.
  </done>
</task>

</tasks>

<verification>
1. Zod schema validates content form inputs (title 5-200 chars, body 50-50k chars)
2. Status state machine prevents invalid transitions (e.g., APPROVED cannot go to DRAFT)
3. Server actions integrate Phase 2 governance validation (validateContent imported)
4. saveDraftAction stores compliance score with each version
5. shouldCreateVersion helper prevents duplicate versions on unchanged content
6. All server actions enforce multi-tenant isolation via x-tenant-id header
7. validateGovernanceAction available for real-time UI validation
</verification>

<success_criteria>
- Content can be created and saved as draft via server action
- Governance validation runs on every save, compliance score stored
- Status transitions validated (DRAFT → SUBMITTED, not DRAFT → APPROVED)
- Versions only created when content actually changes (no noise from auto-save)
- Server actions ready for UI integration in Plan 03-03
- Real-time validation action available for UI governance feedback
</success_criteria>

<output>
After completion, create `.planning/phases/03-content-creation/03-02-SUMMARY.md`
</output>
