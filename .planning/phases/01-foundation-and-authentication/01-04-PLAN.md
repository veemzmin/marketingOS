---
phase: 01-foundation-and-authentication
plan: 04
type: execute
wave: 2
depends_on: ["01-02", "01-03"]
files_modified:
  - src/app/api/auth/send-verification/route.ts
  - src/app/auth/verify-email/page.tsx
  - src/lib/email/client.ts
  - src/app/actions/auth.ts
  - .env.example
autonomous: true
user_setup:
  - service: email_provider
    why: "Send verification emails to users"
    env_vars:
      - name: EMAIL_PROVIDER
        source: "Choose: 'resend', 'sendgrid', 'ses', or 'console' (dev only)"
      - name: RESEND_API_KEY
        source: "Resend Dashboard -> API Keys (if using Resend)"
      - name: EMAIL_FROM
        source: "Verified sender email (e.g., noreply@yourdomain.com)"
    setup_steps:
      - task: "Create Resend account and verify domain"
        url: "https://resend.com/domains"

must_haves:
  truths:
    - "User receives verification email after signup"
    - "User can click verification link to verify email"
    - "User cannot log in until email is verified"
    - "Verification tokens expire after 24 hours"
  artifacts:
    - path: "src/lib/email/client.ts"
      provides: "Email sending abstraction with provider switching"
      exports: ["sendVerificationEmail"]
    - path: "src/app/auth/verify-email/page.tsx"
      provides: "Email verification handler checking token validity"
      min_lines: 40
  key_links:
    - from: "src/app/actions/auth.ts (signupAction)"
      to: "src/lib/email/client.ts (sendVerificationEmail)"
      via: "function call after user creation"
      pattern: "sendVerificationEmail"
    - from: "src/app/auth/verify-email/page.tsx"
      to: "prisma.emailVerificationToken.findUnique"
      via: "token lookup and validation"
      pattern: "findUnique.*token"
---

<objective>
Implement email verification flow where users receive a verification link after signup and must verify their email before logging in.

Purpose: Prevent account creation with typos, reduce spam signups, and ensure users control the email address they register with.
Output: Working email verification flow with token generation, email sending (dev placeholder + production-ready abstraction), and verification handler.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-and-authentication/01-02-SUMMARY.md
@.planning/phases/01-foundation-and-authentication/01-03-SUMMARY.md

# Research guidance
- 24-hour token expiry (healthcare standard)
- EmailVerificationToken table already in schema
- Resend recommended for production (defer provider choice to env var)
</context>

<tasks>

<task type="auto">
  <name>Create email client abstraction</name>
  <files>src/lib/email/client.ts, .env.example, package.json</files>
  <action>
    1. Install Resend (production-ready option): `npm install resend`

    2. Add to .env.example:
       ```
       EMAIL_PROVIDER="console" # console (dev) | resend | sendgrid | ses
       EMAIL_FROM="noreply@example.com"
       RESEND_API_KEY="" # Only needed if EMAIL_PROVIDER=resend
       ```

    3. Create src/lib/email/client.ts:
       ```ts
       import { Resend } from "resend"

       const resend = process.env.RESEND_API_KEY
         ? new Resend(process.env.RESEND_API_KEY)
         : null

       export async function sendEmail({
         to,
         subject,
         html,
       }: {
         to: string
         subject: string
         html: string
       }) {
         const provider = process.env.EMAIL_PROVIDER || "console"

         if (provider === "console") {
           console.log("ðŸ“§ Email (dev mode):")
           console.log(`To: ${to}`)
           console.log(`Subject: ${subject}`)
           console.log(`Body:\n${html}`)
           return { success: true, provider: "console" }
         }

         if (provider === "resend") {
           if (!resend) {
             throw new Error("RESEND_API_KEY not configured")
           }

           const { data, error } = await resend.emails.send({
             from: process.env.EMAIL_FROM!,
             to,
             subject,
             html,
           })

           if (error) {
             throw error
           }

           return { success: true, provider: "resend", data }
         }

         // Add other providers here (SendGrid, SES) as needed
         throw new Error(`Unsupported email provider: ${provider}`)
       }

       export async function sendVerificationEmail({
         to,
         name,
         token,
       }: {
         to: string
         name: string | null
         token: string
       }) {
         const verifyUrl = `${process.env.NEXTAUTH_URL}/auth/verify-email?token=${token}`

         const html = `
           <div style="font-family: sans-serif; max-width: 600px; margin: 0 auto;">
             <h1>Verify Your Email</h1>
             <p>Hi ${name || "there"},</p>
             <p>Thanks for signing up for Marketing OS. Click the link below to verify your email address:</p>
             <p>
               <a href="${verifyUrl}" style="display: inline-block; background: #0070f3; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px;">
                 Verify Email
               </a>
             </p>
             <p>Or copy and paste this link into your browser:</p>
             <p><a href="${verifyUrl}">${verifyUrl}</a></p>
             <p>This link will expire in 24 hours.</p>
             <p>If you didn't create an account, you can safely ignore this email.</p>
           </div>
         `

         return sendEmail({
           to,
           subject: "Verify your Marketing OS account",
           html,
         })
       }
       ```

    Why abstraction: Allows switching email providers via env var without code changes. Console mode for development avoids email setup during early development.
  </action>
  <verify>
    Test console mode by calling sendVerificationEmail with test data - should log email to console.
  </verify>
  <done>
    Email client created with Resend integration, console mode for dev, and sendVerificationEmail helper.
  </done>
</task>

<task type="auto">
  <name>Generate verification tokens on signup</name>
  <files>src/app/actions/auth.ts</files>
  <action>
    Update signupAction in src/app/actions/auth.ts to generate and send verification token:

    ```ts
    import { sendVerificationEmail } from "@/lib/email/client"
    import crypto from "crypto"

    export async function signupAction(formData: FormData) {
      const email = formData.get("email") as string
      const password = formData.get("password") as string
      const name = formData.get("name") as string

      // ... existing validation ...

      // Create user (emailVerified = null)
      const passwordHash = await hashPassword(password)
      const user = await prisma.user.create({
        data: {
          email,
          name,
          passwordHash,
          emailVerified: null,
        },
      })

      // Generate verification token
      const token = crypto.randomUUID()
      const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours

      await prisma.emailVerificationToken.create({
        data: {
          userId: user.id,
          token,
          expiresAt,
        },
      })

      // Send verification email
      try {
        await sendVerificationEmail({
          to: user.email,
          name: user.name,
          token,
        })
      } catch (error) {
        console.error("Failed to send verification email:", error)
        // Don't fail signup if email fails; user can request resend
      }

      return {
        success: true,
        message: "Account created! Check your email to verify your account.",
      }
    }
    ```

    Update authorize in auth.ts to check emailVerified (already implemented in Plan 03).
  </action>
  <verify>
    Sign up new user - should see console log with verification email (in dev mode).
    Check database - EmailVerificationToken should exist with 24h expiry.
  </verify>
  <done>
    Signup generates verification token, creates EmailVerificationToken record, sends verification email.
  </done>
</task>

<task type="auto">
  <name>Build email verification handler</name>
  <files>src/app/auth/verify-email/page.tsx, src/app/actions/auth.ts</files>
  <action>
    1. Create verification server action in src/app/actions/auth.ts:
       ```ts
       export async function verifyEmailAction(token: string) {
         // Find token
         const verification = await prisma.emailVerificationToken.findUnique({
           where: { token },
           include: { user: true },
         })

         if (!verification) {
           return { error: "Invalid verification token" }
         }

         // Check expiry
         if (verification.expiresAt < new Date()) {
           // Delete expired token
           await prisma.emailVerificationToken.delete({ where: { token } })
           return { error: "Verification link expired. Please request a new one." }
         }

         // Mark user as verified
         await prisma.user.update({
           where: { id: verification.userId },
           data: { emailVerified: new Date() },
         })

         // Delete token (one-time use)
         await prisma.emailVerificationToken.delete({ where: { token } })

         return { success: true }
       }

       export async function resendVerificationAction(email: string) {
         const user = await prisma.user.findUnique({ where: { email } })

         if (!user) {
           return { error: "User not found" }
         }

         if (user.emailVerified) {
           return { error: "Email already verified" }
         }

         // Delete old tokens
         await prisma.emailVerificationToken.deleteMany({
           where: { userId: user.id },
         })

         // Generate new token
         const token = crypto.randomUUID()
         const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000)

         await prisma.emailVerificationToken.create({
           data: {
             userId: user.id,
             token,
             expiresAt,
           },
         })

         // Send email
         await sendVerificationEmail({
           to: user.email,
           name: user.name,
           token,
         })

         return { success: true, message: "Verification email sent" }
       }
       ```

    2. Create src/app/auth/verify-email/page.tsx:
       ```tsx
       import { verifyEmailAction } from "@/app/actions/auth"
       import { redirect } from "next/navigation"

       export default async function VerifyEmailPage({
         searchParams,
       }: {
         searchParams: { token?: string }
       }) {
         const token = searchParams.token

         if (!token) {
           return (
             <div className="flex min-h-screen items-center justify-center">
               <div className="text-center">
                 <h1 className="text-2xl font-bold text-red-600">Invalid Link</h1>
                 <p className="mt-2">No verification token provided.</p>
               </div>
             </div>
           )
         }

         const result = await verifyEmailAction(token)

         if (result.error) {
           return (
             <div className="flex min-h-screen items-center justify-center">
               <div className="text-center">
                 <h1 className="text-2xl font-bold text-red-600">Verification Failed</h1>
                 <p className="mt-2">{result.error}</p>
                 <a
                   href="/auth/login"
                   className="mt-4 inline-block text-blue-600 hover:underline"
                 >
                   Back to Login
                 </a>
               </div>
             </div>
           )
         }

         // Success - redirect to login
         redirect("/auth/login?verified=true")
       }
       ```

    3. Update src/app/auth/login/page.tsx to show success message if ?verified=true in URL
  </action>
  <verify>
    1. Sign up new user
    2. Copy verification link from console logs
    3. Visit verification link - should redirect to login with success message
    4. Attempt to log in - should succeed (emailVerified is now set)
    5. Try using same token again - should fail (one-time use)
  </verify>
  <done>
    Email verification handler validates token, checks expiry, marks user as verified, deletes token. Resend functionality allows users to request new verification email.
  </done>
</task>

</tasks>

<verification>
1. Signup creates EmailVerificationToken with 24h expiry
2. Verification email sent (console mode in dev, Resend in production)
3. Verification link validates token and marks email as verified
4. Expired tokens are rejected with clear error
5. Users cannot log in until email verified
6. Tokens are one-time use (deleted after verification)
</verification>

<success_criteria>
- Email verification flow complete from signup to login
- Tokens expire after 24 hours
- Email sending abstraction supports console (dev) and Resend (prod)
- Users must verify email before logging in
- Resend functionality available for expired tokens
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-authentication/01-04-SUMMARY.md`
</output>
