---
phase: 01-foundation-and-authentication
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - package.json
  - auth.ts
  - src/lib/auth/config.ts
  - src/lib/auth/password.ts
  - src/app/api/auth/[...nextauth]/route.ts
  - src/app/auth/login/page.tsx
  - src/app/auth/signup/page.tsx
  - src/app/auth/error/page.tsx
  - .env.example
autonomous: true

must_haves:
  truths:
    - "User can sign up with email and password (AUTH-01)"
    - "User can log in with valid credentials (AUTH-03)"
    - "User can log out from any page (AUTH-04)"
    - "Invalid credentials are rejected with clear error message"
  artifacts:
    - path: "auth.ts"
      provides: "Auth.js configuration with Credentials provider"
      contains: "NextAuth"
    - path: "src/lib/auth/password.ts"
      provides: "bcryptjs password hashing and comparison"
      exports: ["hashPassword", "comparePassword"]
    - path: "src/app/auth/login/page.tsx"
      provides: "Login form with email/password fields"
      min_lines: 50
  key_links:
    - from: "src/app/auth/login/page.tsx"
      to: "/api/auth/signin"
      via: "form action or signIn() call"
      pattern: "signIn.*credentials"
    - from: "auth.ts"
      to: "prisma.user.findUnique"
      via: "authorize function database query"
      pattern: "findUnique.*email"
---

<objective>
Implement core authentication with Auth.js v5, enabling email/password signup, login, and session management via JWT.

Purpose: Establish secure credential-based authentication that will integrate with 2FA and multi-tenant access control.
Output: Working signup and login flows with password hashing, session cookies, and logout functionality.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-and-authentication/01-01-SUMMARY.md
@.planning/phases/01-foundation-and-authentication/01-02-SUMMARY.md

# Research guidance
- Auth.js v5 with Credentials provider
- bcryptjs for password hashing (10 rounds)
- JWT session strategy (stateless)
- HttpOnly cookies for security
</context>

<tasks>

<task type="auto">
  <name>Install Auth.js and configure authentication</name>
  <files>package.json, auth.ts, .env.example, .env</files>
  <action>
    1. Install dependencies:
       ```bash
       npm install next-auth@beta bcryptjs
       npm install -D @types/bcryptjs
       ```

    2. Add to .env.example and .env:
       ```
       NEXTAUTH_URL="http://localhost:3000"
       NEXTAUTH_SECRET="generate-with-openssl-rand-base64-32"
       ```

    3. Generate NEXTAUTH_SECRET: `openssl rand -base64 32` and add to .env

    4. Create auth.ts in project root:
       ```ts
       import NextAuth from "next-auth"
       import Credentials from "next-auth/providers/credentials"
       import { PrismaClient } from "@prisma/client"
       import { comparePassword } from "@/lib/auth/password"

       const prisma = new PrismaClient()

       export const { handlers, signIn, signOut, auth } = NextAuth({
         providers: [
           Credentials({
             credentials: {
               email: { label: "Email", type: "email" },
               password: { label: "Password", type: "password" },
             },
             async authorize(credentials) {
               if (!credentials?.email || !credentials?.password) {
                 return null
               }

               // Find user by email
               const user = await prisma.user.findUnique({
                 where: { email: credentials.email as string },
               })

               if (!user) {
                 return null
               }

               // Check if email is verified (will implement in next plan)
               if (!user.emailVerified) {
                 throw new Error("Email not verified")
               }

               // Verify password
               const isValid = await comparePassword(
                 credentials.password as string,
                 user.passwordHash
               )

               if (!isValid) {
                 return null
               }

               return {
                 id: user.id,
                 email: user.email,
                 name: user.name,
               }
             },
           }),
         ],
         callbacks: {
           async jwt({ token, user }) {
             if (user) {
               token.id = user.id
               token.email = user.email
             }
             return token
           },
           async session({ session, token }) {
             if (session.user) {
               session.user.id = token.id as string
               session.user.email = token.email as string
             }
             return session
           },
         },
         pages: {
           signIn: "/auth/login",
           error: "/auth/error",
         },
         session: {
           strategy: "jwt",
           maxAge: 24 * 60 * 60, // 24 hours
         },
         trustHost: true,
       })
       ```

    5. Create src/app/api/auth/[...nextauth]/route.ts:
       ```ts
       import { handlers } from "@/auth"
       export const { GET, POST } = handlers
       ```
  </action>
  <verify>
    Run `npm run dev` - should start without errors.
    Visit http://localhost:3000/api/auth/providers - should return JSON with "credentials" provider.
  </verify>
  <done>
    Auth.js v5 installed and configured with Credentials provider, JWT session strategy, route handler created.
  </done>
</task>

<task type="auto">
  <name>Create password hashing utilities</name>
  <files>src/lib/auth/password.ts</files>
  <action>
    Create src/lib/auth/password.ts with bcryptjs utilities:

    ```ts
    import bcrypt from "bcryptjs"

    const SALT_ROUNDS = 10

    export async function hashPassword(password: string): Promise<string> {
      return bcrypt.hash(password, SALT_ROUNDS)
    }

    export async function comparePassword(
      password: string,
      hash: string
    ): Promise<boolean> {
      return bcrypt.compare(password, hash)
    }

    export function validatePasswordStrength(password: string): {
      valid: boolean
      errors: string[]
    } {
      const errors: string[] = []

      if (password.length < 12) {
        errors.push("Password must be at least 12 characters")
      }

      if (!/[A-Z]/.test(password)) {
        errors.push("Password must contain at least one uppercase letter")
      }

      if (!/[a-z]/.test(password)) {
        errors.push("Password must contain at least one lowercase letter")
      }

      if (!/[0-9]/.test(password)) {
        errors.push("Password must contain at least one number")
      }

      if (!/[^A-Za-z0-9]/.test(password)) {
        errors.push("Password must contain at least one special character")
      }

      return {
        valid: errors.length === 0,
        errors,
      }
    }
    ```

    Why 12 characters minimum: Healthcare/HIPAA guidelines recommend 12+ character passwords.
  </action>
  <verify>
    Create test file to verify:
    ```ts
    import { hashPassword, comparePassword, validatePasswordStrength } from "./password"

    const hash = await hashPassword("Test123!@#abc")
    console.log(await comparePassword("Test123!@#abc", hash)) // should be true
    console.log(await comparePassword("wrongpass", hash)) // should be false
    console.log(validatePasswordStrength("short")) // should return errors
    ```
  </verify>
  <done>
    Password utilities created with bcryptjs hashing, comparison, and strength validation (12 char min, uppercase, lowercase, number, special char).
  </done>
</task>

<task type="auto">
  <name>Build signup and login UI</name>
  <files>src/app/auth/login/page.tsx, src/app/auth/signup/page.tsx, src/app/auth/error/page.tsx, src/app/actions/auth.ts</files>
  <action>
    1. Create src/app/actions/auth.ts with server actions:
       ```ts
       "use server"

       import { signIn, signOut } from "@/auth"
       import { AuthError } from "next-auth"
       import { prisma } from "@/lib/db/client"
       import { hashPassword, validatePasswordStrength } from "@/lib/auth/password"
       import { redirect } from "next/navigation"

       export async function loginAction(formData: FormData) {
         try {
           await signIn("credentials", {
             email: formData.get("email"),
             password: formData.get("password"),
             redirect: false,
           })
           redirect("/dashboard")
         } catch (error) {
           if (error instanceof AuthError) {
             return { error: error.cause?.err?.message || "Invalid credentials" }
           }
           throw error
         }
       }

       export async function signupAction(formData: FormData) {
         const email = formData.get("email") as string
         const password = formData.get("password") as string
         const name = formData.get("name") as string

         // Validate password strength
         const validation = validatePasswordStrength(password)
         if (!validation.valid) {
           return { error: validation.errors.join(", ") }
         }

         // Check if user exists
         const existing = await prisma.user.findUnique({ where: { email } })
         if (existing) {
           return { error: "Email already registered" }
         }

         // Create user (emailVerified will be null until verified)
         const passwordHash = await hashPassword(password)
         await prisma.user.create({
           data: {
             email,
             name,
             passwordHash,
             emailVerified: null, // Will be set in email verification flow
           },
         })

         return { success: true, message: "Account created. Check your email to verify." }
       }

       export async function logoutAction() {
         await signOut({ redirect: true, redirectTo: "/" })
       }
       ```

    2. Create src/lib/db/client.ts (Prisma singleton):
       ```ts
       import { PrismaClient } from "@prisma/client"

       const globalForPrisma = global as unknown as { prisma: PrismaClient }

       export const prisma =
         globalForPrisma.prisma ||
         new PrismaClient({
           log: process.env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"],
         })

       if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma
       ```

    3. Create src/app/auth/login/page.tsx:
       ```tsx
       import { loginAction } from "@/app/actions/auth"

       export default function LoginPage() {
         return (
           <div className="flex min-h-screen items-center justify-center">
             <div className="w-full max-w-md space-y-8 p-8">
               <h2 className="text-3xl font-bold text-center">Sign In</h2>
               <form action={loginAction} className="space-y-6">
                 <div>
                   <label htmlFor="email" className="block text-sm font-medium">
                     Email
                   </label>
                   <input
                     id="email"
                     name="email"
                     type="email"
                     required
                     className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
                   />
                 </div>
                 <div>
                   <label htmlFor="password" className="block text-sm font-medium">
                     Password
                   </label>
                   <input
                     id="password"
                     name="password"
                     type="password"
                     required
                     className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2"
                   />
                 </div>
                 <button
                   type="submit"
                   className="w-full rounded-md bg-blue-600 px-4 py-2 text-white hover:bg-blue-700"
                 >
                   Sign In
                 </button>
               </form>
               <p className="text-center text-sm">
                 Don't have an account?{" "}
                 <a href="/auth/signup" className="text-blue-600 hover:underline">
                   Sign up
                 </a>
               </p>
             </div>
           </div>
         )
       }
       ```

    4. Create src/app/auth/signup/page.tsx (similar structure with name field and signupAction)

    5. Create src/app/auth/error/page.tsx for auth errors

    6. Create src/app/dashboard/page.tsx (placeholder protected route):
       ```tsx
       import { auth } from "@/auth"
       import { redirect } from "next/navigation"
       import { logoutAction } from "@/app/actions/auth"

       export default async function DashboardPage() {
         const session = await auth()
         if (!session) {
           redirect("/auth/login")
         }

         return (
           <div className="p-8">
             <h1 className="text-2xl font-bold">Dashboard</h1>
             <p>Welcome, {session.user?.email}</p>
             <form action={logoutAction}>
               <button className="mt-4 rounded bg-red-600 px-4 py-2 text-white">
                 Logout
               </button>
             </form>
           </div>
         )
       }
       ```
  </action>
  <verify>
    1. Visit /auth/signup, create account - should succeed (no verification yet)
    2. Temporarily set emailVerified to NOW() in database for test user
    3. Visit /auth/login, enter credentials - should redirect to /dashboard
    4. Click logout - should redirect to home and clear session
  </verify>
  <done>
    Signup page collects email/password/name with strength validation, login page authenticates users, dashboard shows logged-in user with logout button.
  </done>
</task>

</tasks>

<verification>
1. User can sign up with email/password (creates user in database)
2. Password validation enforces 12 char min, uppercase, lowercase, number, special char
3. User can log in with valid credentials (JWT session created)
4. User can log out (session cleared, redirected)
5. Invalid credentials show error message
6. Protected route (/dashboard) requires authentication
</verification>

<success_criteria>
- Auth.js v5 configured with Credentials provider
- Password hashing uses bcryptjs with 10 rounds
- Signup creates user (emailVerified=null until verified)
- Login authenticates and creates JWT session
- Logout clears session
- Dashboard page is protected (requires auth)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-authentication/01-03-SUMMARY.md`
</output>
