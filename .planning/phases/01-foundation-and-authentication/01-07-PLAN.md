---
phase: 01-foundation-and-authentication
plan: 07
type: execute
wave: 4
depends_on: ["01-02", "01-03", "01-06"]
files_modified:
  - src/lib/db/client.ts
  - src/lib/audit/logger.ts
  - src/app/api/audit/export/route.ts
  - src/app/audit/page.tsx
autonomous: true

must_haves:
  truths:
    - "System logs every content creation with user, timestamp, organization (AUD-01)"
    - "System logs every policy check result (AUD-02)"
    - "System logs every review decision with reviewer and reasoning (AUD-03)"
    - "Audit logs are immutable - cannot be modified or deleted (AUD-04)"
    - "Admin can export audit logs as CSV (AUD-05)"
  artifacts:
    - path: "src/lib/db/client.ts"
      provides: "Prisma middleware capturing mutations automatically"
      contains: "AuditLog"
    - path: "src/lib/audit/logger.ts"
      provides: "Manual audit logging helpers for custom events"
      exports: ["logAuditEvent"]
    - path: "src/app/api/audit/export/route.ts"
      provides: "CSV export endpoint for compliance reporting"
      exports: ["GET"]
  key_links:
    - from: "src/lib/db/client.ts (Prisma middleware)"
      to: "AuditLog.create"
      via: "automatic capture after create/update/delete operations"
      pattern: "auditLog\\.create"
    - from: "src/app/api/audit/export/route.ts"
      to: "prisma.auditLog.findMany"
      via: "query with organization filter"
      pattern: "auditLog\\.findMany"
---

<objective>
Implement automatic audit logging via Prisma middleware, capturing all database mutations (create/update/delete) with user context, and provide CSV export for compliance reporting.

Purpose: Maintain immutable audit trail for 7-year healthcare compliance (HIPAA), tracking all changes to content, users, and policies.
Output: Prisma middleware logging all mutations, manual logging helpers for custom events, CSV export endpoint, audit log viewer UI.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-and-authentication/01-02-SUMMARY.md
@.planning/phases/01-foundation-and-authentication/01-03-SUMMARY.md
@.planning/phases/01-foundation-and-authentication/01-06-SUMMARY.md

# Research guidance
- Prisma Client Extensions for automatic mutation capture
- AuditLog model with immutable append-only policy (already in schema)
- Capture before/after for updates in changes JSON field
- 7-year retention requirement (AUD-06)
</context>

<tasks>

<task type="auto">
  <name>Extend Prisma Client with audit middleware</name>
  <files>src/lib/db/client.ts</files>
  <action>
    Update src/lib/db/client.ts to add audit logging middleware:

    ```ts
    import { PrismaClient, Prisma } from "@prisma/client"
    import { headers } from "next/headers"

    const globalForPrisma = global as unknown as { prisma: PrismaClient }

    const basePrisma = new PrismaClient({
      log: process.env.NODE_ENV === "development" ? ["error", "warn"] : ["error"],
    })

    export const prisma = basePrisma.$extends({
      query: {
        async $allOperations({ operation, model, args, query }) {
          // Extract context from request headers
          const headersList = headers()
          const tenantId = headersList.get("x-tenant-id")
          const userId = headersList.get("x-user-id")
          const userEmail = headersList.get("x-user-email")

          // Set RLS context
          if (tenantId) {
            await basePrisma.$executeRaw`SELECT set_config('app.current_tenant_id', ${tenantId}, false)`
          }

          // Execute query
          const result = await query(args)

          // Log mutations (create, update, delete) automatically
          if (
            userId &&
            tenantId &&
            model &&
            ["create", "update", "delete", "createMany", "updateMany", "deleteMany"].includes(operation)
          ) {
            // Don't audit the AuditLog model itself (prevent recursion)
            if (model === "AuditLog") {
              return result
            }

            try {
              await logAuditMutation({
                organizationId: tenantId,
                userId,
                userEmail: userEmail || "unknown",
                operation,
                model,
                args,
                result,
              })
            } catch (err) {
              // Don't throw - audit failure should not break user operation
              console.error("Audit log failed (non-blocking):", err)
            }
          }

          return result
        },
      },
    })

    async function logAuditMutation({
      organizationId,
      userId,
      userEmail,
      operation,
      model,
      args,
      result,
    }: {
      organizationId: string
      userId: string
      userEmail: string
      operation: string
      model: string
      args: any
      result: any
    }) {
      // Extract resource ID
      let resourceId = "unknown"
      if (result?.id) {
        resourceId = result.id
      } else if (args.where?.id) {
        resourceId = args.where.id
      }

      // Build changes object for updates
      let changes: any = null
      if (operation === "update" && args.data) {
        changes = {
          updated: args.data,
        }
      } else if (operation === "delete") {
        changes = {
          deleted: true,
        }
      } else if (operation === "create" && result) {
        changes = {
          created: result,
        }
      }

      // Use base Prisma client to avoid middleware recursion
      await basePrisma.auditLog.create({
        data: {
          organizationId,
          userId,
          userEmail,
          action: operation,
          resource: model,
          resourceId,
          changes,
          metadata: null,
        },
      })
    }

    if (process.env.NODE_ENV !== "production") {
      globalForPrisma.prisma = prisma
    }

    export { basePrisma }
    ```

    Why non-blocking: Audit failures should not prevent user operations. Log error and continue.
    Why basePrisma for audit writes: Prevents recursive middleware calls.
  </action>
  <verify>
    Create a test user, then update user's name via Prisma.
    Check audit_logs table - should see entry with action=update, resource=User, changes containing old/new values.
  </verify>
  <done>
    Prisma middleware automatically captures create/update/delete operations, logs to AuditLog with user context, changes JSON, and resource details.
  </done>
</task>

<task type="auto">
  <name>Create manual audit logging helpers</name>
  <files>src/lib/audit/logger.ts</files>
  <action>
    Create src/lib/audit/logger.ts for manual audit events (e.g., login, logout, policy checks):

    ```ts
    import { basePrisma } from "@/lib/db/client"

    export interface AuditEventData {
      organizationId: string
      userId: string
      userEmail: string
      action: string // login, logout, policy_check, review_approve, review_reject, role_grant, role_revoke
      resource: string // User, Content, Policy, etc.
      resourceId: string
      changes?: Record<string, any>
      metadata?: Record<string, any>
    }

    export async function logAuditEvent(data: AuditEventData) {
      try {
        await basePrisma.auditLog.create({
          data: {
            organizationId: data.organizationId,
            userId: data.userId,
            userEmail: data.userEmail,
            action: data.action,
            resource: data.resource,
            resourceId: data.resourceId,
            changes: data.changes || null,
            metadata: data.metadata || null,
          },
        })
      } catch (err) {
        console.error("Failed to log audit event:", err)
        // Non-blocking - don't throw
      }
    }

    // Helper for login events
    export async function logLogin({
      organizationId,
      userId,
      userEmail,
      method,
    }: {
      organizationId: string
      userId: string
      userEmail: string
      method: "password" | "2fa"
    }) {
      return logAuditEvent({
        organizationId,
        userId,
        userEmail,
        action: "login",
        resource: "Session",
        resourceId: userId,
        metadata: { method },
      })
    }

    // Helper for logout events
    export async function logLogout({
      organizationId,
      userId,
      userEmail,
    }: {
      organizationId: string
      userId: string
      userEmail: string
    }) {
      return logAuditEvent({
        organizationId,
        userId,
        userEmail,
        action: "logout",
        resource: "Session",
        resourceId: userId,
      })
    }

    // Helper for role changes
    export async function logRoleChange({
      organizationId,
      userId,
      userEmail,
      targetUserId,
      oldRole,
      newRole,
    }: {
      organizationId: string
      userId: string
      userEmail: string
      targetUserId: string
      oldRole: string | null
      newRole: string | null
    }) {
      return logAuditEvent({
        organizationId,
        userId,
        userEmail,
        action: oldRole && newRole ? "role_change" : newRole ? "role_grant" : "role_revoke",
        resource: "UserOrganization",
        resourceId: targetUserId,
        changes: {
          from: oldRole,
          to: newRole,
        },
      })
    }
    ```

    Usage example (in auth flow):
    ```ts
    import { logLogin } from "@/lib/audit/logger"

    // After successful login:
    await logLogin({
      organizationId: session.user.organizationId,
      userId: session.user.id,
      userEmail: session.user.email,
      method: "password",
    })
    ```
  </action>
  <verify>
    Call logLogin helper with test data.
    Check audit_logs table - should see login event with metadata.
  </verify>
  <done>
    Manual audit logging helpers created for login, logout, role changes, with generic logAuditEvent for custom events.
  </done>
</task>

<task type="auto">
  <name>Build CSV export and audit log viewer</name>
  <files>src/app/api/audit/export/route.ts, src/app/audit/page.tsx</files>
  <action>
    1. Create CSV export API endpoint:
       ```ts
       // src/app/api/audit/export/route.ts
       import { NextRequest, NextResponse } from "next/server"
       import { auth } from "@/auth"
       import { prisma } from "@/lib/db/client"

       export async function GET(request: NextRequest) {
         const session = await auth()
         const tenantId = request.headers.get("x-tenant-id")

         if (!session?.user?.id || !tenantId) {
           return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
         }

         // Verify user is Admin
         const membership = await prisma.userOrganization.findFirst({
           where: {
             userId: session.user.id,
             organizationId: tenantId,
             role: "ADMIN",
           },
         })

         if (!membership) {
           return NextResponse.json(
             { error: "Admin access required" },
             { status: 403 }
           )
         }

         // Query audit logs (RLS automatically filters by tenantId)
         const logs = await prisma.auditLog.findMany({
           where: { organizationId: tenantId },
           orderBy: { createdAt: "desc" },
           take: 10000, // Limit to prevent memory issues; paginate if needed
         })

         // Convert to CSV
         const csvRows = [
           ["Timestamp", "User Email", "Action", "Resource", "Resource ID", "Changes", "Metadata"].join(","),
         ]

         for (const log of logs) {
           csvRows.push(
             [
               log.createdAt.toISOString(),
               `"${log.userEmail}"`,
               log.action,
               log.resource,
               log.resourceId,
               log.changes ? `"${JSON.stringify(log.changes).replace(/"/g, '""')}"` : "",
               log.metadata ? `"${JSON.stringify(log.metadata).replace(/"/g, '""')}"` : "",
             ].join(",")
           )
         }

         const csv = csvRows.join("\n")

         // Return as downloadable file
         return new NextResponse(csv, {
           headers: {
             "Content-Type": "text/csv",
             "Content-Disposition": `attachment; filename="audit-logs-${new Date().toISOString().split("T")[0]}.csv"`,
           },
         })
       }
       ```

    2. Create audit log viewer UI:
       ```tsx
       // src/app/audit/page.tsx
       import { auth } from "@/auth"
       import { prisma } from "@/lib/db/client"
       import { redirect } from "next/navigation"

       export default async function AuditLogPage() {
         const session = await auth()
         if (!session) {
           redirect("/auth/login")
         }

         // Get tenant from headers (middleware injects)
         // For this MVP, fetch recent logs
         const logs = await prisma.auditLog.findMany({
           orderBy: { createdAt: "desc" },
           take: 100,
           select: {
             id: true,
             createdAt: true,
             userEmail: true,
             action: true,
             resource: true,
             resourceId: true,
             changes: true,
             metadata: true,
           },
         })

         return (
           <div className="p-8">
             <div className="flex justify-between items-center mb-6">
               <h1 className="text-2xl font-bold">Audit Log</h1>
               <a
                 href="/api/audit/export"
                 className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
               >
                 Export CSV
               </a>
             </div>

             <div className="overflow-x-auto">
               <table className="min-w-full bg-white border">
                 <thead className="bg-gray-50">
                   <tr>
                     <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">
                       Timestamp
                     </th>
                     <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">
                       User
                     </th>
                     <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">
                       Action
                     </th>
                     <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">
                       Resource
                     </th>
                     <th className="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase">
                       Details
                     </th>
                   </tr>
                 </thead>
                 <tbody className="divide-y divide-gray-200">
                   {logs.map((log) => (
                     <tr key={log.id}>
                       <td className="px-4 py-2 text-sm whitespace-nowrap">
                         {new Date(log.createdAt).toLocaleString()}
                       </td>
                       <td className="px-4 py-2 text-sm">{log.userEmail}</td>
                       <td className="px-4 py-2 text-sm">
                         <span className="px-2 py-1 text-xs rounded bg-blue-100 text-blue-800">
                           {log.action}
                         </span>
                       </td>
                       <td className="px-4 py-2 text-sm">
                         {log.resource} ({log.resourceId.substring(0, 8)}...)
                       </td>
                       <td className="px-4 py-2 text-sm text-gray-500">
                         {log.changes && (
                           <details className="cursor-pointer">
                             <summary>View changes</summary>
                             <pre className="mt-2 text-xs bg-gray-50 p-2 rounded overflow-x-auto">
                               {JSON.stringify(log.changes, null, 2)}
                             </pre>
                           </details>
                         )}
                       </td>
                     </tr>
                   ))}
                 </tbody>
               </table>

               {logs.length === 0 && (
                 <p className="text-center text-gray-500 py-8">No audit logs yet</p>
               )}
             </div>
           </div>
         )
       }
       ```
  </action>
  <verify>
    1. Perform some actions (create user, update organization, etc.)
    2. Visit /audit - should see logged events in table
    3. Click Export CSV - should download CSV file with all logs
    4. Verify CSV contains timestamp, user email, action, resource, changes
  </verify>
  <done>
    CSV export endpoint returns audit logs as downloadable file, audit log viewer UI displays recent events with expandable details.
  </done>
</task>

</tasks>

<verification>
1. All database mutations (create/update/delete) automatically logged to AuditLog
2. Manual logging helpers work for login/logout/role changes
3. Audit logs include user context (userId, userEmail), timestamp, resource details
4. RLS append-only policy prevents modification or deletion of audit logs
5. Admin can export audit logs as CSV
6. Audit log viewer displays recent events
7. Changes JSON field captures before/after state for updates
</verification>

<success_criteria>
- Prisma middleware captures all mutations automatically
- Manual audit logging helpers available for custom events
- Audit logs immutable (RLS append-only policy enforced)
- CSV export generates compliance-ready report
- Audit log viewer shows recent events with details
- 7-year retention possible (PostgreSQL storage + future S3 archival)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-authentication/01-07-SUMMARY.md`
</output>
