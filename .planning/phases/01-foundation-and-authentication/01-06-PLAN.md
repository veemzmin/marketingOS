---
phase: 01-foundation-and-authentication
plan: 06
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/middleware.ts
  - src/lib/db/client.ts
  - src/lib/middleware/tenant-context.ts
  - src/app/api/test-isolation/route.ts
  - prisma/migrations/*
autonomous: true

must_haves:
  truths:
    - "System extracts organization context from subdomain or path (TENT-02)"
    - "System enforces organization context in all database queries (TENT-03)"
    - "PostgreSQL RLS policies prevent cross-tenant data access (TENT-04)"
    - "Concurrent requests to different tenants see only their own data (TENT-05)"
  artifacts:
    - path: "src/middleware.ts"
      provides: "Next.js middleware extracting tenant from subdomain/path"
      contains: "x-tenant-id"
    - path: "src/lib/db/client.ts"
      provides: "Prisma Client extended with RLS context setting"
      contains: "set_config"
  key_links:
    - from: "src/middleware.ts"
      to: "request headers (x-tenant-id)"
      via: "header injection after tenant validation"
      pattern: "x-tenant-id"
    - from: "src/lib/db/client.ts"
      to: "PostgreSQL session variable (app.current_tenant_id)"
      via: "set_config query before operations"
      pattern: "app\\.current_tenant_id"
---

<objective>
Implement multi-tenant isolation via Next.js middleware (subdomain/path extraction) and Prisma Client Extensions (PostgreSQL RLS context), ensuring complete data segregation between organizations.

Purpose: Enforce tenant boundaries at both application and database layers (defense-in-depth), preventing cross-tenant data leaks.
Output: Middleware extracting tenant context, Prisma middleware setting RLS variables, isolation tests passing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-and-authentication/01-02-SUMMARY.md
@.planning/phases/01-foundation-and-authentication/01-03-SUMMARY.md

# Research guidance
- Extract tenant from subdomain (acme.example.com -> acme) or path (/org/acme)
- Set PostgreSQL session variable: set_config('app.current_tenant_id', ...)
- Use Prisma Client Extensions for middleware
- RLS policies already created in Plan 02
</context>

<tasks>

<task type="auto">
  <name>Create tenant extraction middleware</name>
  <files>src/middleware.ts, src/lib/middleware/tenant-context.ts</files>
  <action>
    1. Create src/lib/middleware/tenant-context.ts:
       ```ts
       import { NextRequest, NextResponse } from "next/server"
       import { prisma } from "@/lib/db/client"

       export async function extractTenantContext(
         request: NextRequest,
         userId: string | undefined
       ): Promise<{
         tenantId: string | null
         response: NextResponse | null
       }> {
         // Strategy 1: Subdomain (production)
         // Example: acme.marketingos.com -> slug=acme
         const host = request.headers.get("x-forwarded-host") || request.headers.get("host") || ""
         const parts = host.split(".")

         // Check if subdomain exists (not www, not apex domain)
         if (parts.length >= 3 && parts[0] !== "www" && parts[0] !== "localhost") {
           const slug = parts[0]

           const org = await prisma.organization.findUnique({
             where: { slug },
             select: { id: true },
           })

           if (org) {
             // Verify user has access (if authenticated)
             if (userId) {
               const membership = await prisma.userOrganization.findFirst({
                 where: {
                   userId,
                   organizationId: org.id,
                 },
               })

               if (!membership) {
                 return {
                   tenantId: null,
                   response: NextResponse.redirect(new URL("/unauthorized", request.url)),
                 }
               }
             }

             return { tenantId: org.id, response: null }
           }
         }

         // Strategy 2: Path-based (development/fallback)
         // Example: /org/acme/dashboard -> slug=acme
         const pathMatch = request.nextUrl.pathname.match(/^\/org\/([^\/]+)/)
         if (pathMatch) {
           const slug = pathMatch[1]

           const org = await prisma.organization.findUnique({
             where: { slug },
             select: { id: true },
           })

           if (org) {
             // Verify user access
             if (userId) {
               const membership = await prisma.userOrganization.findFirst({
                 where: {
                   userId,
                   organizationId: org.id,
                 },
               })

               if (!membership) {
                 return {
                   tenantId: null,
                   response: NextResponse.redirect(new URL("/unauthorized", request.url)),
                 }
               }
             }

             return { tenantId: org.id, response: null }
           }
         }

         // No tenant context (public routes)
         return { tenantId: null, response: null }
       }
       ```

    2. Create src/middleware.ts:
       ```ts
       import { NextRequest, NextResponse } from "next/server"
       import { auth } from "./auth"
       import { extractTenantContext } from "./lib/middleware/tenant-context"

       export async function middleware(request: NextRequest) {
         const session = await auth()

         // Extract tenant context
         const { tenantId, response } = await extractTenantContext(
           request,
           session?.user?.id
         )

         if (response) {
           return response // Early return (redirect or error)
         }

         // Inject tenant context into headers for downstream use
         const requestHeaders = new Headers(request.headers)
         if (tenantId) {
           requestHeaders.set("x-tenant-id", tenantId)
         }
         if (session?.user?.id) {
           requestHeaders.set("x-user-id", session.user.id)
           requestHeaders.set("x-user-email", session.user.email || "")
         }

         return NextResponse.next({
           request: {
             headers: requestHeaders,
           },
         })
       }

       export const config = {
         matcher: [
           // Include all routes except static files and auth endpoints
           "/((?!_next/static|_next/image|favicon.ico|api/auth).*)",
         ],
       }
       ```

    Why headers not cookies: Headers are request-scoped, preventing cross-request contamination. Cookies could leak tenant context across tabs.
  </action>
  <verify>
    Add console.log in middleware to print x-tenant-id header.
    Visit /org/test-org/dashboard - should log tenant ID.
  </verify>
  <done>
    Middleware extracts tenant from subdomain or path, verifies user access, injects x-tenant-id and x-user-id headers.
  </done>
</task>

<task type="auto">
  <name>Extend Prisma Client with RLS context setting</name>
  <files>src/lib/db/client.ts</files>
  <action>
    Update src/lib/db/client.ts to set PostgreSQL session variable before queries:

    ```ts
    import { PrismaClient } from "@prisma/client"
    import { headers } from "next/headers"

    const globalForPrisma = global as unknown as { prisma: PrismaClient }

    const basePrisma = new PrismaClient({
      log: process.env.NODE_ENV === "development" ? ["error", "warn"] : ["error"],
    })

    export const prisma = basePrisma.$extends({
      query: {
        async $allOperations({ operation, model, args, query }) {
          // Extract tenant context from request headers
          const headersList = headers()
          const tenantId = headersList.get("x-tenant-id")

          if (tenantId) {
            // Set PostgreSQL session variable for RLS
            // This makes current_setting('app.current_tenant_id') available in RLS policies
            await basePrisma.$executeRaw`SELECT set_config('app.current_tenant_id', ${tenantId}, false)`
          }

          // Execute the query (RLS policies now apply)
          return query(args)
        },
      },
    })

    if (process.env.NODE_ENV !== "production") {
      globalForPrisma.prisma = prisma
    }

    // Export base client for direct use (e.g., in middleware before headers available)
    export { basePrisma }
    ```

    CRITICAL: Use `false` (not `true`) in set_config third parameter.
    - `true` = SET LOCAL (transaction-scoped, resets at COMMIT)
    - `false` = SET (session-scoped, persists until connection released)

    For connection pools, session-scoped is safer because each request gets a new "session" from pool perspective.

    Alternative if using transactions heavily:
    ```ts
    // In transaction contexts:
    await prisma.$executeRaw`SELECT set_config('app.current_tenant_id', ${tenantId}, true)`
    ```
  </action>
  <verify>
    Query organizations via prisma.organization.findMany() with x-tenant-id header set.
    Check PostgreSQL logs - should see SET statement before SELECT.
  </verify>
  <done>
    Prisma Client extended to set PostgreSQL session variable (app.current_tenant_id) before all operations, enabling RLS enforcement.
  </done>
</task>

<task type="auto">
  <name>Create tenant isolation test endpoint</name>
  <files>src/app/api/test-isolation/route.ts, src/app/unauthorized/page.tsx</files>
  <action>
    1. Create test endpoint to verify isolation:
       ```ts
       // src/app/api/test-isolation/route.ts
       import { NextRequest, NextResponse } from "next/server"
       import { prisma } from "@/lib/db/client"

       export async function GET(request: NextRequest) {
         const tenantId = request.headers.get("x-tenant-id")

         if (!tenantId) {
           return NextResponse.json({ error: "No tenant context" }, { status: 400 })
         }

         // Query all organizations (should only return current tenant due to RLS)
         const orgs = await prisma.organization.findMany({
           select: { id: true, name: true, slug: true },
         })

         // Query user organizations (should only return current tenant's memberships)
         const userOrgs = await prisma.userOrganization.findMany({
           select: {
             id: true,
             organizationId: true,
             userId: true,
             role: true,
           },
         })

         return NextResponse.json({
           tenantId,
           orgsVisible: orgs.length,
           organizations: orgs,
           userOrgsVisible: userOrgs.length,
           userOrganizations: userOrgs,
           message: "If RLS working correctly, should only see current tenant data",
         })
       }
       ```

    2. Create unauthorized page:
       ```tsx
       // src/app/unauthorized/page.tsx
       export default function UnauthorizedPage() {
         return (
           <div className="flex min-h-screen items-center justify-center">
             <div className="text-center">
               <h1 className="text-2xl font-bold text-red-600">Access Denied</h1>
               <p className="mt-2 text-gray-600">
                 You don't have permission to access this organization.
               </p>
               <a
                 href="/"
                 className="mt-4 inline-block text-blue-600 hover:underline"
               >
                 Return Home
               </a>
             </div>
           </div>
         )
       }
       ```

    3. Manual test procedure (document in SUMMARY):
       ```bash
       # Create two test organizations in database
       psql $DATABASE_URL -c "INSERT INTO organizations (id, slug, name) VALUES
         ('org-test-1', 'acme', 'Acme Corp'),
         ('org-test-2', 'globex', 'Globex Inc');"

       # Create test user and memberships
       # (Use signup flow or manual SQL)

       # Test isolation:
       # 1. Visit /org/acme/api/test-isolation - should only see org-test-1
       # 2. Visit /org/globex/api/test-isolation - should only see org-test-2
       # 3. User in acme trying /org/globex should get 401
       ```
  </action>
  <verify>
    1. Create two organizations in database
    2. Assign user to one organization
    3. Visit /org/{org-slug}/api/test-isolation for assigned org - should see data
    4. Visit /org/{other-org-slug}/api/test-isolation - should redirect to /unauthorized
    5. Check returned data - should only contain assigned org's records
  </verify>
  <done>
    Isolation test endpoint verifies RLS policies work correctly, unauthorized page handles access denials.
  </done>
</task>

</tasks>

<verification>
1. Middleware extracts tenant from subdomain or /org/{slug} path
2. Middleware injects x-tenant-id header into requests
3. Prisma Client sets PostgreSQL session variable before queries
4. RLS policies restrict queries to current tenant only
5. Users cannot access organizations they don't belong to
6. Test endpoint confirms isolation between tenants
</verification>

<success_criteria>
- Middleware extracts tenant context from subdomain or path
- x-tenant-id header injected into all requests
- Prisma Client sets app.current_tenant_id PostgreSQL variable
- RLS policies enforce tenant isolation (verified via test endpoint)
- Cross-tenant access attempts redirect to /unauthorized
- Defense-in-depth: app-layer + database-layer isolation
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-authentication/01-06-SUMMARY.md`
</output>
